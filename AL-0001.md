title: AL
categories:
  - Assembly Language
---
## <font color="#008B8B">**第一章 基础知识**</font>

**机器语言//机器指令的集合**

不同型号CPU代表位数不同
MASM 汇编环境

**汇编指令 MOV AX,BX**
MOV - 操作码
AX - 目的操作数
BX - 源操作数
——将寄存器BX的内容送到AX中

程序员——汇编指令——编译器——机器码——计算机

汇编语言由汇编指令、伪指令、其他符号三类指令组成。

**存储器**
cache
主存
外存
显存

**指令和数据**
十六位进制数最高位如果是字母，须在该字母前补零。
但该0不占存储空间。

**存储单元**
编号从零开始。
Eg. 一个存储器由128个存储单元，则编号为0~127

一个存储单元 1个byte = 8个bit
1 word =2个byte

**CPU对存储器的读写**
CPU——内存
地址总线 - 有多少个数位，就可以传送多少个数位
数据总线
控制总线
MOV AX,[3] —— 将三号单元的内容送到AX，有括号代表3号单元里的内容，五括号则代表3本身。

思考：为什么64根总线没有都用，内存16G？（部分地址总线充当控制总线）

**地址总线**
有N根，则宽为N。

**控制总线**
决定CPU对系统中其他器件的控制能力。

**小结**
汇编指令是机器指令的助记符，同机器指令一一对应。
每一种CPU都有自己的汇编指令集。
嵌入式，不是CPU，是MCU。
CPU厂家多为Intel和AMD，MCU厂家很多。

**主板**
计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。

**接口卡**

**各类存储器芯片**
RAM&ROM

**内存地址空间**

## <font color="#008B8B">**第二章 寄存器**</font>

8086CPU有14个寄存器，它们的名称为：
AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW

8086CPU的上一代CPU中的存储器都是8位的，为保证兼容，使原来基于上一代CPU编写的程序也可以运行在8086之上。
可以把16位寄存器分为两个可以独立使用的8位寄存器。
AX可分为AH和AL（high/low）

操作类型匹配。（期末考试考点）
一个字节送到两个字节，运行无问题，但两个字节送到一个字节，会导致内存溢出，出错。

！汇编指令不区分大小写。

内存并没有真的被分层/分段，内存本身是连续的，段的划分是CPU逻辑上的一种管理方式。

CS和IP是最关键的寄存器，它们指示了当前要读取指令的地址。

地址，高对高，低对低。

mov指令不能用于设置CS、IP的值。

同时修改CS、IP的内容：
jmp 段地址：偏移地址
    jmp 2AE3:3
    jmp 3:0B16

仅修改IP的内容：
jmp某一合法寄存器
    jmp ax (类似于mov IP,ax，但这个不对)
    jmp bx

## <font color="#008B8B">**第三章 寄存器（内存访问）**</font>

低地址，可以表示字节/字/双字。

Eg.
ax 1123
bx 6622 -> 6622+2211 = 8833
cx 2211 -> 2211+6622 = 8833

mov指令：
寄存器，数据
寄存器，寄存器
寄存器，内存单元
内存单元，寄存器
段寄存器，寄存器

**栈**
先进后出，后进先出。

低地址作为栈顶，高地址作为栈底。
栈顶指针sp
Push ax 时，sp=sp-2。

初始化栈：
mov ax, 1000H
mov ss, ax
mov sp, 0010H

一个栈最大可以设位64KB，2的16次方——因为16根数据线。

## <font color="#008B8B">**第五章 [BX]和loop指令**</font>

数据在哪儿？- 寻址
1 立即数寻址 mov ax,012BH
2 寄存器直接寻址 mov ax,bx
3 间接寻址 - 在存储器中：基址寻址（bx或bp中）/变址寻址（si或di中）/基址+变址寻址（eg.mov ax,[bx][di]） /相对基址加变址寻址

## <font color="#008B8B">**第七章 更灵活的定位内存地址的方法**</font>

ASCII码中a为61H，A为41H。
小写和大写之间差了20H。
